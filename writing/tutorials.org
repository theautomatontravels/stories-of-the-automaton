#+OPTIONS: toc:nil num:nil
#+LATEX_HEADER: \usepackage[a4paper, margin=1in]{geometry}
#+LATEX_HEADER: \usepackage{lmodern}

For recording, Emacs should be at 129 x 34 (probably :o)

* Creating a Static Website from an Org File
 
Oh my. It seems we are at that point in our lives where we're wanting to create a simple web site containing the scripts of all the fun and cool videos we've been making the past few weeks. That's especially true for me!

If you didn't know already, I'm the compiler of the Stories of the Automaton. If you don't know what that is, that's okay. This tutorial is unrelated to those stories. However, I would sure appreciate it if you gave those videos a watch after watching this one.

** Outline

First thing's first, let's try to outline exactly what we're going to be doing in this tutorial. The scripts for the Stories of the Automaton are written in a markup format called =org=. If you're not familiar with =org=, it's kind of like =markdown=. It's a plain text file format that works well with the text editor I use. =org= files are useful for the Stories of the Automaton videos because I can convert them to =pdf= files that I can print. That way I can slip the printed scripts under my girlfriend's office door and expect her to get back to me with feedback on her own time.

What we're going to go through in this instructional video is how to convert those =org= files (actually just one =org= file) to =html= documents. That way we can make a globally available website out of the scripts to show to the whole world instead of just the floor of my girlfriend's office.

However, in order to convert an =org= file, we're first going to have to be able to read an =org= file. To do that we'll be writing a parser. There's a couple =org= parsers already written that we could use, but it wouldn't be as fun or cool if we didn't write our own.

We'll be using =parsimmon= to create a parser. =parsimmon= is a monadic LL(infinity) parser combinator library for JavaScript. Don't worry about that description, though. It's practically meaningless!

We're going to use =parsimmon= to create a handful of little parsers that will be combined together in the end to create one regular parser. To keep it easy on ourselves, the parser won't handle the whole spectrum of =org= syntax. We're only going to worry about what we /need/ to worry about.

Once we can read an =org= file, we can then try to convert it to =html=. We'll use =react= to do that, since =react= is easily the most popular JavaScript library on the Internet. Not only will more people be able to better understand this video, there will be more people interested in this video to possibly be converted into views for the Stories of the Automaton.

** Parsimmon

First, let's create a new language with =parsimmon=.

#+BEGIN_SRC javascript
  const OrgLang = P.createLanguage({})
#+END_SRC 

This language is going to hold the individual parts of the =org= syntax we're concerning ourself with. The specific parts will be:
- keywords
- headers
- properties
- paragraphs

Keywords aren't very important to what we're doing, but we have to deal with it because it's related to the =pdf= generation I talked about earlier.

The header syntax will eventually relate to our =html= =h2= tags. The paragraph syntax will similarly be for the =html= =p= tags.

The properties syntax will hold the url associated with the original YouTube video. The properties syntax is the most important, because the whole point of this endeavor is to generate more views on the Stories of the Automaton videos.

In the end, our new =parsimmon= language will also handle putting each of these little parsers together. It will then be able to give us a JavaScript object representative of the parsed =org= file.

*** Parsing Org Keywords

An =org= file keyword looks like this:

#+BEGIN_SRC org
  #+OPTIONS: toc:nil
  #+LATEX_HEADER: \usepackage[a4paper, margin=1in]{geometry}
  #+LATEX_HEADER: \usepackage{lmodern}
#+END_SRC

An =org= keyword is a sequence of ~#+~, then a series of letters and underscores, then a single ~:~, followed by anything up until a line terminator. The associated little parser might look like this. It's a sequence of four littler parsers, whose parsed values are mapped to an object. Whatever the second littler parser parses becomes the name, whatever the fourth littler parser parses becomes the value.

The specific examples of =org= keywords here will make it so that a =pdf= will not include a table of contents, it will have the correct dimensions for a sheet of a4 premium printer paper, and it will use a font which looks a little bit better than the default font.

#+BEGIN_SRC javascript
  const OrgLang = P.createLanguage({
    KeyWord: () =>
      P.seqMap(
        P.string("#+"),
        P.regexp(/\w+/),
        P.string(":"),
        P.regexp(/.*/),
        (_1, name, _3, value) => ({
          type: "keyword",
          name: name.trim(),
          value: value.trim(),
        })
      ),
  })
#+END_SRC 

*** Parsing Org Hedaers

=org= file headers look like this:

#+BEGIN_SRC org
  * I am a header
  ** I am also a header, but I have a different level than the one before me
#+END_SRC

An =org= header is a sequence of asterisks, then at least one space, followed by anything until a line terminator. We can add its definition to our ~parsimmon~ language so far. We use the same technique as before, leveraging ~parsimmon~'s very fun and cool ~seqMap~ function to map the parsed values of the given little parsers to a JavaScript object with useful structure.

#+BEGIN_SRC javascript
  const OrgLang = P.createLanguage({
    // ...
    Header: () =>
      P.seqMap(
        P.regexp(/\*+/),
        P.regexp(/ +/),
        P.regexp(/.*/),
        (stars, _2, header) => ({
          type: 'header',
          level: stars.length,
          value: header.trim()
        })
      ),
  })
#+END_SRC 

*** Parsing Org Properties

=org= file properties look like this:

#+BEGIN_SRC org
  :PROPERTIES:
  :url: https://theautomatontravels.github.io/stories-of-the-automaton/
  :END:
#+END_SRC

The properties syntax in =org= is referred to as a properties drawer, since your text editor is meant to be able to open and close it like a drawer. We again employ the same technique using ~seqMap~ to define the little parser. We start and end with the =properties= and =end= syntax. What goes in between is parsed by another little parser we name =PropertyPair=. There may be many property pairs separated by new lines and maybe some trailing whitespace characters.

#+BEGIN_SRC javascript
  const OrgLang = P.createLanguage({
    // ...
    Properties: (r) =>
      P.seqMap(
        P.regexp(/[ ]*:PROPERTIES:[ ]*\n/),
        r.PropertyPair.sepBy(P.regex(/\n\s*/)),
        P.regexp(/\n[ ]*:END:[ ]*/),
          (_1, pairs, _2) => ({
            type: "properties",
            value: pairs.reduce(
                (r, { key, value }) => ({ ...r, [key]: value }),
                {}
              ),
        })
    ),
  })
#+END_SRC

The keys in our properties drawer key-value pairs are letters wrapped by colons, and we allow there to be some preceding whitespace. The values are whatever comes after the key syntax except line terminators.

#+BEGIN_SRC javascript
  const OrgLang = createLanguage({
    // ...
    PropertyPair: (r) =>
      P.seqMap(
          P.regexp(/ *:(\w+):/i, 1),
          P.regexp(/.+/),
          (key, value) => ({
            type: "property-pair",
            key,
            value: value.trim(),
          })
      ),
    // ...
  })
#+END_SRC

*** Parsing Org Paragraphs

Finally, we add =org= paragraphs to our =parsimmon= language. The majority of what our language needs to parse is paragraphs. Paragraphs are the most straightforward. It's just a somewhat complicated character set that we map to our JavaScript object. The character set handles all the usual syntax of English writing. Words, digits, spaces, punctuation, quotations, hyphens and parentheses, as well as some markup language syntax characters like asterisks and slashes used for emphasis.

#+BEGIN_SRC javascript
  const OrgLang = P.createLanguage({
    // ...
    Text: () => P.regexp(/[\w\d .!?;:,'"\-()*/]+/),
    Paragraph: (r) =>
      r.Text.map((value) => ({
        type: "paragraph",
        value: value.trim(),     
      })),
    // ...
  })
#+END_SRC

*** Putting Them All Together

We then put all the little parsers together into one regular parser for the whole collection of relevant =org= syntaxes we'll be using, key words, headers, properties, and paragraphs. In an =org= file, the parts of the language are separated by newline characters and maybe some trailing whitespace characters. This resulting parser will give us a JavaScript array object representative of the original =org= file.
    
#+BEGIN_SRC javascript
  const OrgLang = P.createLanguage({
    // ...
    File: (r) =>
      P.alt(r.KeyWord, r.Header, r.Properties, r.Paragraph)
          .sepBy(
              P.regexp(/((\n+)(\s*))+/)
          )
  })
#+END_SRC

We'll have to clean this up a little, since we'll want to break up the different collections of paragraphs and their preceding headers into different sections that will represent the individual =html= pages we're going to make. We'll use some handy array transformation functions provided by the =ramda= library. We should be able to do most of the work in just one function, we'll call it =toSections=.

First, we're going to drop anything that isn't a header from our input. This will be those keywords that we had to define in our =parsimmon= language. We don't need them for our current use case.

The way we're using the =dropWhile= function makes it so that the first element in our array is guaranteed to be a header. So let's assign a variable for it and move on. We'll then split the rest of the array at the position of the next header. We're making the assumption that our =org= file doesn't have any nested headers. The Stories of the Automaton doesn't make use of nested headers in any way yet, so this should be okay. We'll call the everything before the next header =sectionContent=, and the rest will be =remaining=.

At the moment we're always putting our properties right after the header. Anything remaining is just going to be a paragraph. So let's assign some variables for the properties and the paragraphs and move on.

All the remaining content looks identical, so we can use the same function recursively to handle for it. Since we're making the function recursive, we need to handle for when there's no more work to do. At some point, there aren't going to be any more headers left to section off. This will be when the array is empty. So when our input array is empty let's just return an empty array. It will spread into the nothing for the previous call of the recursive function and allow it to return.

#+BEGIN_SRC javascript
  import { dropWhile, splitWhen } from 'ramda'
  function toSections(orgArrayObject) {
    orgArrayObject = dropWhile(
      node => node.type !== 'header',
      orgArrayObject
    )
    if (!orgArrayObject.length) return []
    const header = orgArrayObject[0]
    const [sectionContent, remaining] = splitWhen(
      node => node.type !== 'header',
      orgArrayObject.slice(1)
    )
    const properties = sectionContent[0]
    const paragraphs = sectionContent.slice(1)
    return [
      {
        header,
        properties,
        paragraphs
      }, 
      ...toSections(remaining)
    ]
  }
#+END_SRC

** TODO React
